<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Prism</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0f;
      --bg-elevated: #12121a;
      --bg-card: #1a1a24;
      --bg-hover: #252532;
      --border: #2a2a3a;
      --text: #ffffff;
      --text-secondary: #a0a0b0;
      --text-muted: #6a6a7a;
      --accent: #8b5cf6;
      --blue: #3b82f6;
      --purple: #8b5cf6;
      --green: #22c55e;
      --orange: #f97316;
      --pink: #ec4899;
      --red: #ef4444;
      --yellow: #eab308;
      --cyan: #06b6d4;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
    }

    /* Header */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 56px;
      background: var(--bg-elevated);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 20px;
      gap: 20px;
      z-index: 100;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-icon {
      width: 36px;
      height: 36px;
      background: linear-gradient(135deg, var(--purple), var(--blue));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logo-icon i { width: 20px; height: 20px; color: white; }
    .logo h1 { font-size: 16px; font-weight: 700; }

    .lens-tabs {
      display: flex;
      background: var(--bg-card);
      border-radius: 8px;
      padding: 4px;
    }

    .lens-tab {
      padding: 8px 14px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .lens-tab:hover { color: var(--text); }
    .lens-tab.active { background: var(--accent); color: white; }
    .lens-tab i { width: 14px; height: 14px; }

    .header-spacer { flex: 1; }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .control-btn {
      padding: 8px 12px;
      font-size: 11px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .control-btn:hover { border-color: var(--accent); color: var(--accent); }
    .control-btn i { width: 14px; height: 14px; }

    /* Canvas Container */
    .canvas-container {
      position: fixed;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      touch-action: none; /* Enable touch pan/zoom */
    }

    #mainSvg {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #mainSvg:active {
      cursor: grabbing;
    }

    /* Tree Node Styles - Circle Mind Map */
    .tree-node { cursor: pointer; }

    .node-circle {
      transition: all 0.2s;
    }

    .tree-node:hover .node-circle {
      filter: drop-shadow(0 0 12px currentColor);
      transform: scale(1.05);
    }

    .tree-node.selected .node-circle {
      stroke-width: 3;
      filter: drop-shadow(0 0 16px currentColor);
    }

    .tree-node.expanded .node-circle {
      filter: drop-shadow(0 0 20px currentColor);
    }

    .tree-node.expanded .node-glow {
      opacity: 0.8;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.8; }
    }

    .node-label {
      font-family: 'Inter', sans-serif;
      pointer-events: none;
      text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    }

    .expand-indicator {
      transition: all 0.2s;
    }

    .expand-indicator:hover {
      transform: scale(1.2);
    }

    /* Links */
    .tree-link {
      fill: none;
      stroke: var(--border);
      stroke-width: 2;
    }

    .tree-link.highlighted {
      stroke: var(--accent);
      stroke-width: 3;
    }

    .tree-link-animated {
      fill: none;
      stroke: var(--accent);
      stroke-width: 3;
      stroke-dasharray: 8 4;
      animation: flowAnimation 1s linear infinite;
    }

    @keyframes flowAnimation {
      from { stroke-dashoffset: 12; }
      to { stroke-dashoffset: 0; }
    }

    .flow-arrow { fill: var(--accent); }

    /* Expand/Collapse button */
    .expand-btn { cursor: pointer; }

    .expand-btn circle {
      fill: var(--bg-card);
      stroke: var(--border);
      stroke-width: 2;
      transition: all 0.2s;
    }

    .expand-btn:hover circle {
      stroke: var(--accent);
      fill: var(--bg-hover);
    }

    .expand-btn text {
      font-size: 14px;
      font-weight: 700;
      fill: var(--text-secondary);
      text-anchor: middle;
      dominant-baseline: central;
    }

    /* Layout Toggle */
    .layout-toggle {
      position: fixed;
      top: 72px;
      left: 20px;
      display: flex;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px;
      z-index: 50;
    }

    .layout-btn {
      padding: 8px 14px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
      background: transparent;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .layout-btn:hover { color: var(--text); }
    .layout-btn.active { background: var(--accent); color: white; }
    .layout-btn i { width: 12px; height: 12px; }

    /* Detail Panel */
    .detail-panel {
      position: fixed;
      top: 56px;
      right: 0;
      width: 380px;
      height: calc(100vh - 56px);
      background: var(--bg-elevated);
      border-left: 1px solid var(--border);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      display: flex;
      flex-direction: column;
      z-index: 50;
    }

    .detail-panel.visible { transform: translateX(0); }

    .detail-header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    .detail-header-top {
      display: flex;
      align-items: flex-start;
      gap: 14px;
    }

    .detail-icon {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .detail-icon i { width: 24px; height: 24px; }

    .detail-title-area { flex: 1; }
    .detail-title { font-size: 18px; font-weight: 700; margin-bottom: 4px; }
    .detail-type { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }

    .detail-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
    }

    .detail-close:hover { color: var(--text); }

    .detail-tech-stack {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 14px;
    }

    .detail-tech {
      padding: 4px 10px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 11px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
    }

    .detail-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .detail-section {
      margin-bottom: 24px;
    }

    .detail-section h4 {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .detail-section h4 i { width: 14px; height: 14px; }

    .detail-section p {
      font-size: 13px;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    .detail-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .detail-list-item {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-card);
      border-radius: 8px;
      font-size: 12px;
    }

    .detail-list-item i {
      width: 16px;
      height: 16px;
      color: var(--accent);
      flex-shrink: 0;
      margin-top: 2px;
    }

    .flow-diagram {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 16px;
    }

    .flow-step {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }

    .flow-step:last-child { border-bottom: none; }

    .flow-step-num {
      width: 24px;
      height: 24px;
      background: var(--accent);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .flow-step-content { flex: 1; }
    .flow-step-title { font-size: 12px; font-weight: 600; }
    .flow-step-desc { font-size: 10px; color: var(--text-muted); margin-top: 2px; }

    .connections-grid { display: grid; gap: 8px; }

    .connection-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-card);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .connection-item:hover { background: var(--bg-hover); }

    .connection-dot {
      width: 10px;
      height: 10px;
      border-radius: 3px;
    }

    .connection-info { flex: 1; }
    .connection-name { font-size: 12px; font-weight: 500; }
    .connection-type { font-size: 10px; color: var(--text-muted); }
    .connection-arrow { color: var(--text-muted); }

    /* Legend */
    .legend {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px 18px;
      z-index: 50;
    }

    .legend-title {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .legend-items {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 10px;
      color: var(--text-secondary);
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }

    /* Controls Panel */
    .controls-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      z-index: 50;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 200px;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .control-label {
      font-size: 10px;
      color: var(--text-muted);
      min-width: 70px;
    }

    .control-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      background: var(--bg-hover);
      border-radius: 2px;
      outline: none;
    }

    .control-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
    }

    .control-value {
      font-size: 10px;
      color: var(--accent);
      min-width: 30px;
      text-align: right;
      font-family: 'JetBrains Mono', monospace;
    }

    /* Minimap */
    .minimap {
      position: fixed;
      bottom: 140px;
      right: 20px;
      width: 180px;
      height: 120px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      z-index: 50;
    }

    .minimap-header {
      padding: 6px 10px;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
    }

    .minimap-content {
      width: 100%;
      height: calc(100% - 24px);
    }

    /* Keyboard Hints */
    .keyboard-hints {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 16px;
      font-size: 10px;
      color: var(--text-muted);
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 16px;
      z-index: 40;
    }

    .keyboard-hints kbd {
      padding: 2px 6px;
      background: var(--bg-hover);
      border-radius: 3px;
      margin-right: 4px;
      font-family: 'JetBrains Mono', monospace;
    }
  </style>
</head>
<body>

  <div class="header">
    <div class="logo">
      <div class="logo-icon"><i data-lucide="prism"></i></div>
      <h1>Project Prism</h1>
    </div>

    <div class="lens-tabs">
      <button class="lens-tab active" data-lens="tree"><i data-lucide="git-branch"></i> Tech Tree</button>
    </div>

    <div class="header-spacer"></div>

    <div class="header-controls">
      <button class="control-btn" onclick="showAllSatellites()" title="Show all tech stacks">
        <i data-lucide="cpu"></i> Show Tech
      </button>
      <button class="control-btn" onclick="hideAllSatellites()" title="Hide all tech stacks">
        <i data-lucide="eye-off"></i> Hide Tech
      </button>
      <button class="control-btn" onclick="expandAll()">
        <i data-lucide="unfold-vertical"></i> Expand
      </button>
      <button class="control-btn" onclick="collapseAll()">
        <i data-lucide="fold-vertical"></i> Collapse
      </button>
      <button class="control-btn" onclick="resetView()">
        <i data-lucide="maximize-2"></i> Reset
      </button>
    </div>
  </div>

  <!-- Layout Toggle -->
  <div class="layout-toggle">
    <button class="layout-btn active" data-layout="vertical">
      <i data-lucide="arrow-down"></i> Vertical
    </button>
    <button class="layout-btn" data-layout="horizontal">
      <i data-lucide="arrow-right"></i> Horizontal
    </button>
    <button class="layout-btn" data-layout="radial">
      <i data-lucide="circle"></i> Radial
    </button>
  </div>

  <div class="canvas-container">
    <svg id="mainSvg"></svg>
  </div>

  <!-- Detail Panel -->
  <div class="detail-panel" id="detailPanel">
    <div class="detail-header">
      <div class="detail-header-top">
        <div class="detail-icon" id="detailIcon">
          <i data-lucide="box"></i>
        </div>
        <div class="detail-title-area">
          <div class="detail-title" id="detailTitle">Component</div>
          <div class="detail-type" id="detailType">Type</div>
        </div>
        <button class="detail-close" onclick="closeDetail()">
          <i data-lucide="x"></i>
        </button>
      </div>
      <div class="detail-tech-stack" id="detailTechStack"></div>
    </div>
    <div class="detail-content" id="detailContent"></div>
  </div>

  <!-- Legend -->
  <div class="legend">
    <div class="legend-title">Click nodes to show tech stack</div>
    <div class="legend-items">
      <div class="legend-item"><div class="legend-dot" style="background: #8b5cf6"></div> Core</div>
      <div class="legend-item"><div class="legend-dot" style="background: #3b82f6"></div> Frontend</div>
      <div class="legend-item"><div class="legend-dot" style="background: #22c55e"></div> Backend</div>
      <div class="legend-item"><div class="legend-dot" style="background: #f97316"></div> Data</div>
      <div class="legend-item"><div class="legend-dot" style="background: #ec4899"></div> Flow</div>
      <div class="legend-item"><div class="legend-dot" style="background: #06b6d4"></div> Infra</div>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls-panel">
    <div class="control-row">
      <span class="control-label">Node Size</span>
      <input type="range" class="control-slider" id="nodeSizeSlider" min="0.5" max="1.5" step="0.1" value="1">
      <span class="control-value" id="nodeSizeValue">1.0x</span>
    </div>
    <div class="control-row">
      <span class="control-label">Spacing</span>
      <input type="range" class="control-slider" id="spacingSlider" min="150" max="400" step="25" value="250">
      <span class="control-value" id="spacingValue">250</span>
    </div>
  </div>

  <!-- Minimap -->
  <div class="minimap">
    <div class="minimap-header">Overview</div>
    <svg class="minimap-content" id="minimapSvg"></svg>
  </div>

  <!-- Keyboard Hints -->
  <div class="keyboard-hints">
    <span><kbd>Click</kbd> Toggle tech</span>
    <span><kbd>V</kbd> <kbd>H</kbd> <kbd>R</kbd> Layout</span>
    <span><kbd>Esc</kbd> Close panel</span>
  </div>

  <script>
    // ============================================
    // TECH TREE DATA - HYBRID: BRANCHES + CHAINS
    // ============================================
    const techTreeData = {
      name: "System Architecture",
      type: "core",
      icon: "layers",
      color: "#8b5cf6",
      tech: ["Microservices", "Cloud Native"],
      badges: ["Root", "Overview"],
      description: "Full system architecture with parallel components and sequential flows",
      children: [
        // ===== PARALLEL BRANCHES =====
        {
          name: "Frontend Apps",
          type: "frontend",
          icon: "monitor",
          color: "#3b82f6",
          tech: ["React", "TypeScript"],
          badges: ["Parallel", "Branch"],
          description: "User-facing applications",
          children: [
            {
              name: "Web App",
              type: "frontend",
              icon: "globe",
              color: "#3b82f6",
              tech: ["Next.js", "Tailwind"],
              badges: ["SSR", "PWA"],
              description: "Main web application"
            },
            {
              name: "Mobile App",
              type: "frontend",
              icon: "smartphone",
              color: "#3b82f6",
              tech: ["React Native"],
              badges: ["iOS", "Android"],
              description: "Cross-platform mobile"
            },
            {
              name: "Admin Portal",
              type: "frontend",
              icon: "layout-dashboard",
              color: "#3b82f6",
              tech: ["React Admin"],
              badges: ["Internal"],
              description: "Management interface"
            }
          ]
        },
        {
          name: "Backend Services",
          type: "backend",
          icon: "server",
          color: "#22c55e",
          tech: ["Node.js", "Python"],
          badges: ["Parallel", "Microservices"],
          description: "Independent services",
          children: [
            {
              name: "Auth Service",
              type: "backend",
              icon: "lock",
              color: "#22c55e",
              tech: ["JWT", "OAuth2"],
              badges: ["Stateless", "Critical"],
              description: "Authentication & authorization"
            },
            {
              name: "Order Service",
              type: "backend",
              icon: "clipboard-list",
              color: "#22c55e",
              tech: ["Python", "Celery"],
              badges: ["Async", "Queue"],
              description: "Order management"
            },
            {
              name: "Payment Service",
              type: "backend",
              icon: "credit-card",
              color: "#22c55e",
              tech: ["Stripe SDK"],
              badges: ["PCI", "Critical"],
              description: "Payment processing"
            },
            {
              name: "Notification Service",
              type: "backend",
              icon: "bell",
              color: "#22c55e",
              tech: ["SendGrid", "Twilio"],
              badges: ["Async", "Fire&Forget"],
              description: "Email & SMS"
            }
          ]
        },
        {
          name: "Data Stores",
          type: "data",
          icon: "database",
          color: "#f97316",
          tech: ["PostgreSQL", "Redis"],
          badges: ["Parallel", "Replicated"],
          description: "Persistence layer",
          children: [
            {
              name: "PostgreSQL",
              type: "data",
              icon: "database",
              color: "#f97316",
              tech: ["PostgreSQL 15"],
              badges: ["Primary", "ACID"],
              description: "Main database"
            },
            {
              name: "Redis",
              type: "data",
              icon: "zap",
              color: "#f97316",
              tech: ["Redis 7"],
              badges: ["Cache", "Sessions"],
              description: "In-memory store"
            },
            {
              name: "Elasticsearch",
              type: "data",
              icon: "search",
              color: "#f97316",
              tech: ["ES 8"],
              badges: ["Search", "Analytics"],
              description: "Full-text search"
            },
            {
              name: "S3 Storage",
              type: "data",
              icon: "hard-drive",
              color: "#f97316",
              tech: ["AWS S3"],
              badges: ["Blob", "CDN"],
              description: "File storage"
            }
          ]
        },
        // ===== SEQUENTIAL CHAIN =====
        {
          name: "Request Flow",
          type: "flow",
          icon: "workflow",
          color: "#ec4899",
          tech: ["HTTP/2", "REST"],
          badges: ["Sequential", "Chain"],
          description: "How a request flows through the system",
          flow: [
            { step: "Client", desc: "Sends request" },
            { step: "Gateway", desc: "Routes it" },
            { step: "Service", desc: "Processes it" },
            { step: "Data", desc: "Fetches data" },
            { step: "Response", desc: "Returns" }
          ],
          children: [
            {
              name: "Client Request",
              type: "phase1",
              icon: "monitor",
              color: "#3b82f6",
              tech: ["Fetch API"],
              badges: ["Step 1", "Entry"],
              description: "User initiates action",
              children: [
                {
                  name: "API Gateway",
                  type: "phase2",
                  icon: "shield",
                  color: "#22c55e",
                  tech: ["Kong"],
                  badges: ["Step 2", "Auth"],
                  description: "Authenticates & routes",
                  children: [
                    {
                      name: "Business Logic",
                      type: "phase3",
                      icon: "cpu",
                      color: "#f97316",
                      tech: ["Express"],
                      badges: ["Step 3", "Core"],
                      description: "Processes request",
                      children: [
                        {
                          name: "Data Access",
                          type: "phase4",
                          icon: "database",
                          color: "#ec4899",
                          tech: ["Prisma"],
                          badges: ["Step 4", "Query"],
                          description: "Retrieves data",
                          children: [
                            {
                              name: "Response",
                              type: "phase5",
                              icon: "send",
                              color: "#06b6d4",
                              tech: ["JSON"],
                              badges: ["Step 5", "Exit"],
                              description: "Returns to client"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        // ===== INFRASTRUCTURE =====
        {
          name: "Infrastructure",
          type: "infra",
          icon: "cloud",
          color: "#06b6d4",
          tech: ["AWS", "K8s"],
          badges: ["Parallel", "Cloud"],
          description: "Cloud infrastructure",
          children: [
            {
              name: "Kubernetes",
              type: "infra",
              icon: "boxes",
              color: "#06b6d4",
              tech: ["EKS", "Helm"],
              badges: ["Orchestration", "HA"],
              description: "Container platform"
            },
            {
              name: "CI/CD Pipeline",
              type: "infra",
              icon: "git-branch",
              color: "#06b6d4",
              tech: ["GitHub Actions"],
              badges: ["Automation", "Deploy"],
              description: "Continuous deployment"
            },
            {
              name: "Monitoring",
              type: "infra",
              icon: "activity",
              color: "#06b6d4",
              tech: ["Prometheus"],
              badges: ["Metrics", "Alerts"],
              description: "Observability"
            }
          ]
        }
      ]
    };

    // ============================================
    // STATE
    // ============================================
    let currentLayout = 'vertical';
    let showFlowAnimation = false;
    let selectedNode = null;
    let nodeScale = 1;
    let spacing = 250;

    // Track which nodes have their satellites expanded (by node name)
    const expandedSatellites = new Set();

    // Circle node dimensions
    const nodeRadius = 32;
    const nodeWidth = nodeRadius * 2;  // For compatibility
    const nodeHeight = nodeRadius * 2;

    // ============================================
    // SETUP SVG
    // ============================================
    const svg = d3.select('#mainSvg');
    const width = window.innerWidth;
    const height = window.innerHeight - 56;

    svg.attr('width', width).attr('height', height);

    // Arrow markers
    const defs = svg.append('defs');

    defs.append('marker')
      .attr('id', 'arrow')
      .attr('viewBox', '0 0 10 10')
      .attr('refX', 10)
      .attr('refY', 5)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M 0 0 L 10 5 L 0 10 z')
      .attr('class', 'flow-arrow');

    defs.append('marker')
      .attr('id', 'arrow-animated')
      .attr('viewBox', '0 0 10 10')
      .attr('refX', 10)
      .attr('refY', 5)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M 0 0 L 10 5 L 0 10 z')
      .attr('class', 'flow-arrow');

    const g = svg.append('g');

    // Store the current rendered hierarchy for minimap/reset
    let currentRoot = null;

    // Zoom
    const zoom = d3.zoom()
      .scaleExtent([0.2, 3])
      .on('zoom', (e) => {
        g.attr('transform', e.transform);
        updateMinimap();
      });

    svg.call(zoom)
      .on('dblclick.zoom', null); // Disable double-click zoom

    // ============================================
    // RENDER TREE
    // ============================================
    function render() {
      g.selectAll('*').remove();
      selectedNode = null; // Clear selection on re-render

      // Create hierarchy and store it globally for minimap/reset
      const root = d3.hierarchy(techTreeData);
      currentRoot = root;

      // Apply layout
      let treeLayout;
      const scaledSpacing = spacing * nodeScale;

      if (currentLayout === 'radial') {
        // For radial: calculate based on tree depth
        const nodeCount = root.descendants().length;
        const maxDepth = d3.max(root.descendants(), d => d.depth);
        const radiusPerLevel = 200 * nodeScale; // Distance between each ring

        treeLayout = d3.tree()
          .size([2 * Math.PI, maxDepth * radiusPerLevel])
          .separation((a, b) => {
            // More separation for nodes at same level
            return (a.parent === b.parent ? 2 : 3) / (a.depth || 1);
          });
      } else {
        // For circle nodes, use tighter spacing
        const nodeSpacing = (nodeRadius * 2 + 80) * nodeScale;
        treeLayout = d3.tree()
          .nodeSize([nodeSpacing, scaledSpacing]);
      }

      treeLayout(root);

      // Calculate positions based on layout
      root.descendants().forEach(d => {
        if (currentLayout === 'radial') {
          // d.x is angle (0 to 2*PI), d.y is radius from center
          const angle = d.x - Math.PI / 2; // Rotate so top is at 12 o'clock
          const radius = d.y + 120; // Minimum radius so root has space
          // Store original for satellites
          d._angle = d.x;
          d._radius = radius;
          // Convert to cartesian
          d.x = radius * Math.cos(angle);
          d.y = radius * Math.sin(angle);
        } else if (currentLayout === 'horizontal') {
          const temp = d.x;
          d.x = d.y;
          d.y = temp;
        }
      });

      // Draw links
      const links = g.append('g').attr('class', 'links');

      root.links().forEach(link => {
        const r = nodeRadius * nodeScale;

        let path;
        if (currentLayout === 'horizontal') {
          // Connect from right edge to left edge
          const sourceX = link.source.x + r;
          const sourceY = link.source.y;
          const targetX = link.target.x - r;
          const targetY = link.target.y;
          const midX = (sourceX + targetX) / 2;
          path = `M ${sourceX} ${sourceY} C ${midX} ${sourceY}, ${midX} ${targetY}, ${targetX} ${targetY}`;
        } else if (currentLayout === 'radial') {
          // For radial, draw curved lines between circles
          const sourceX = link.source.x;
          const sourceY = link.source.y;
          const targetX = link.target.x;
          const targetY = link.target.y;
          const midX = (sourceX + targetX) / 2;
          const midY = (sourceY + targetY) / 2;
          const pullFactor = 0.7;
          const ctrlX = midX * pullFactor;
          const ctrlY = midY * pullFactor;
          path = `M ${sourceX} ${sourceY} Q ${ctrlX} ${ctrlY}, ${targetX} ${targetY}`;
        } else {
          // Vertical layout - connect from bottom to top of circles
          const sourceX = link.source.x;
          const sourceY = link.source.y + r;
          const targetX = link.target.x;
          const targetY = link.target.y - r;
          const midY = (sourceY + targetY) / 2;
          path = `M ${sourceX} ${sourceY} C ${sourceX} ${midY}, ${targetX} ${midY}, ${targetX} ${targetY}`;
        }

        // Static link
        links.append('path')
          .attr('class', 'tree-link')
          .attr('d', path)
          .attr('data-source', link.source.data.name)
          .attr('data-target', link.target.data.name);

        // Animated link (hidden by default)
        links.append('path')
          .attr('class', 'tree-link-animated')
          .attr('d', path)
          .attr('marker-end', 'url(#arrow-animated)')
          .style('opacity', showFlowAnimation ? 1 : 0);
      });

      // Draw nodes - CIRCLE STYLE (mind map)
      const nodes = g.append('g').attr('class', 'nodes');

      root.descendants().forEach(d => {
        const r = nodeRadius * nodeScale;
        const nodeG = nodes.append('g')
          .attr('class', 'tree-node')
          .attr('transform', `translate(${d.x}, ${d.y})`)
          .attr('data-id', d.data.name)
          .on('click', (e) => {
            e.stopPropagation();
            selectNode(d);
          });

        // Outer glow ring (shows when expanded/has tech)
        const techCount = d.data.tech?.length || 0;
        if (techCount > 0) {
          nodeG.append('circle')
            .attr('class', 'node-glow')
            .attr('r', r + 6)
            .attr('fill', 'none')
            .attr('stroke', d.data.color)
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '4,4')
            .attr('opacity', 0.4);
        }

        // Main circle
        nodeG.append('circle')
          .attr('class', 'node-circle')
          .attr('r', r)
          .attr('fill', d.data.color)
          .attr('stroke', '#fff')
          .attr('stroke-width', 2);

        // Icon in center
        nodeG.append('foreignObject')
          .attr('x', -r * 0.5)
          .attr('y', -r * 0.5)
          .attr('width', r)
          .attr('height', r)
          .append('xhtml:div')
          .style('width', '100%')
          .style('height', '100%')
          .style('display', 'flex')
          .style('align-items', 'center')
          .style('justify-content', 'center')
          .style('color', 'white')
          .html(`<i data-lucide="${d.data.icon}" style="width: ${r * 0.6}px; height: ${r * 0.6}px;"></i>`);

        // Label below circle
        nodeG.append('text')
          .attr('class', 'node-label')
          .attr('y', r + 16)
          .attr('text-anchor', 'middle')
          .attr('fill', '#fff')
          .attr('font-size', `${11 * nodeScale}px`)
          .attr('font-weight', '500')
          .text(d.data.name.length > 14 ? d.data.name.substring(0, 12) + '..' : d.data.name);

        // Tech count badge (small circle)
        if (techCount > 0) {
          nodeG.append('circle')
            .attr('cx', r * 0.7)
            .attr('cy', -r * 0.7)
            .attr('r', 10 * nodeScale)
            .attr('fill', '#1a1a24')
            .attr('stroke', d.data.color)
            .attr('stroke-width', 2);

          nodeG.append('text')
            .attr('x', r * 0.7)
            .attr('y', -r * 0.7 + 4)
            .attr('text-anchor', 'middle')
            .attr('fill', d.data.color)
            .attr('font-size', `${9 * nodeScale}px`)
            .attr('font-weight', '700')
            .text(techCount);
        }

        // Expand/collapse indicator if has children
        const childCount = (d.children || d._children || []).length;
        if (childCount > 0) {
          nodeG.append('circle')
            .attr('class', 'expand-indicator')
            .attr('cy', r + 2)
            .attr('r', 8 * nodeScale)
            .attr('fill', '#1a1a24')
            .attr('stroke', d.data.color)
            .attr('stroke-width', 1.5)
            .style('cursor', 'pointer')
            .on('click', (e) => {
              e.stopPropagation();
              toggleNode(d);
            });

          nodeG.append('text')
            .attr('y', r + 6)
            .attr('text-anchor', 'middle')
            .attr('fill', d.data.color)
            .attr('font-size', `${10 * nodeScale}px`)
            .attr('font-weight', '700')
            .style('pointer-events', 'none')
            .text(d.children ? 'âˆ’' : '+');
        }
      });

      // Tech satellites will be drawn when a node is selected
      // (see drawTechSatellites function)

      lucide.createIcons();
      updateMinimap();

      // Redraw any expanded satellites after re-render
      redrawAllSatellites();
    }

    // ============================================
    // NODE INTERACTIONS
    // ============================================
    // Draw satellites for a SINGLE node - small circles orbiting around
    function drawSatellitesForNode(d) {
      const techTags = d.data.tech || [];
      if (!techTags || techTags.length === 0) return;
      if (typeof d.x !== 'number' || typeof d.y !== 'number') return;

      const nodeId = d.data.name.replace(/[^a-zA-Z0-9]/g, '_');
      const r = nodeRadius * nodeScale;
      const satRadius = 18 * nodeScale; // Small satellite circles
      const orbitRadius = r + 50 * nodeScale; // Distance from center

      // Create satellite group
      const satelliteG = g.append('g')
        .attr('class', 'tech-satellites')
        .attr('data-node-id', nodeId)
        .style('pointer-events', 'none');

      // Calculate angle spread for satellites
      let startAngle, angleStep;

      if (currentLayout === 'radial') {
        // For radial: spread satellites perpendicular to radial direction
        const baseAngle = d._angle !== undefined ? d._angle : Math.atan2(d.y, d.x) + Math.PI / 2;
        const spread = Math.PI * 0.6; // 108 degree spread
        startAngle = baseAngle - spread / 2;
        angleStep = techTags.length > 1 ? spread / (techTags.length - 1) : 0;
      } else if (currentLayout === 'horizontal') {
        // For horizontal: satellites above and below
        startAngle = -Math.PI / 2 - (techTags.length - 1) * 0.3;
        angleStep = 0.6;
      } else {
        // For vertical: satellites to the right side
        startAngle = -Math.PI / 4;
        angleStep = techTags.length > 1 ? (Math.PI / 2) / (techTags.length - 1) : 0;
      }

      techTags.forEach((tech, i) => {
        const angle = startAngle + i * angleStep;
        const satX = d.x + Math.cos(angle) * orbitRadius;
        const satY = d.y + Math.sin(angle) * orbitRadius;

        // Connection line from main node to satellite
        const edgeX = d.x + Math.cos(angle) * r;
        const edgeY = d.y + Math.sin(angle) * r;
        const satEdgeX = satX - Math.cos(angle) * satRadius;
        const satEdgeY = satY - Math.sin(angle) * satRadius;

        satelliteG.append('line')
          .attr('x1', edgeX)
          .attr('y1', edgeY)
          .attr('x2', satEdgeX)
          .attr('y2', satEdgeY)
          .attr('stroke', d.data.color)
          .attr('stroke-width', 1.5)
          .attr('opacity', 0.6);

        // Satellite circle
        satelliteG.append('circle')
          .attr('cx', satX)
          .attr('cy', satY)
          .attr('r', satRadius)
          .attr('fill', '#1a1a24')
          .attr('stroke', d.data.color)
          .attr('stroke-width', 2);

        // Tech label inside satellite
        satelliteG.append('text')
          .attr('x', satX)
          .attr('y', satY + 3)
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .attr('font-size', `${8 * nodeScale}px`)
          .attr('font-family', "'JetBrains Mono', monospace")
          .attr('fill', d.data.color)
          .attr('font-weight', '600')
          .text(tech.length > 6 ? tech.substring(0, 5) + '..' : tech);
      });
    }

    // Toggle satellites for a node (show/hide on click)
    function toggleSatellites(d) {
      const nodeId = d.data.name.replace(/[^a-zA-Z0-9]/g, '_');

      if (expandedSatellites.has(d.data.name)) {
        // Hide satellites for this node
        g.selectAll(`.tech-satellites[data-node-id="${nodeId}"]`).remove();
        expandedSatellites.delete(d.data.name);
        // Update node visual state
        g.selectAll(`.tree-node[data-id="${d.data.name}"]`).classed('expanded', false);
      } else {
        // Show satellites for this node
        drawSatellitesForNode(d);
        expandedSatellites.add(d.data.name);
        // Update node visual state
        g.selectAll(`.tree-node[data-id="${d.data.name}"]`).classed('expanded', true);
      }
    }

    // Redraw all expanded satellites (called after render)
    function redrawAllSatellites() {
      if (!currentRoot || expandedSatellites.size === 0) return;

      // Find nodes that should have satellites shown
      currentRoot.descendants().forEach(d => {
        if (expandedSatellites.has(d.data.name)) {
          drawSatellitesForNode(d);
          g.selectAll(`.tree-node[data-id="${d.data.name}"]`).classed('expanded', true);
        }
      });
    }

    // Show all tech satellites at once
    function showAllSatellites() {
      if (!currentRoot) return;
      currentRoot.descendants().forEach(d => {
        if (d.data.tech && d.data.tech.length > 0 && !expandedSatellites.has(d.data.name)) {
          expandedSatellites.add(d.data.name);
          drawSatellitesForNode(d);
          g.selectAll(`.tree-node[data-id="${d.data.name}"]`).classed('expanded', true);
        }
      });
    }

    // Hide all tech satellites
    function hideAllSatellites() {
      g.selectAll('.tech-satellites').remove();
      expandedSatellites.clear();
      g.selectAll('.tree-node').classed('expanded', false);
    }

    function selectNode(d) {
      selectedNode = d;

      // Update selected visual state
      g.selectAll('.tree-node').classed('selected', false);
      g.selectAll(`.tree-node[data-id="${d.data.name}"]`).classed('selected', true);

      // Highlight connected links using data attributes
      g.selectAll('.tree-link').classed('highlighted', function() {
        const source = d3.select(this).attr('data-source');
        const target = d3.select(this).attr('data-target');
        return source === d.data.name || target === d.data.name;
      });

      // Toggle satellites for this node (persistent - stays until clicked again)
      if (d.data.tech && d.data.tech.length > 0) {
        toggleSatellites(d);
      }

      showDetail(d.data);
    }

    function toggleNode(d) {
      if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
      render();
    }

    function showDetail(data) {
      const panel = document.getElementById('detailPanel');

      document.getElementById('detailTitle').textContent = data.name;
      document.getElementById('detailType').textContent = data.type.toUpperCase();

      const icon = document.getElementById('detailIcon');
      icon.style.background = `${data.color}22`;
      icon.style.color = data.color;
      icon.innerHTML = `<i data-lucide="${data.icon}"></i>`;

      // Tech stack
      document.getElementById('detailTechStack').innerHTML = (data.tech || [])
        .map(t => `<span class="detail-tech">${t}</span>`)
        .join('');

      // Content
      let html = '';

      // Description
      if (data.description) {
        html += `
          <div class="detail-section">
            <h4><i data-lucide="info"></i> Description</h4>
            <p>${data.description}</p>
          </div>
        `;
      }

      // Contains
      if (data.contains && data.contains.length > 0) {
        html += `
          <div class="detail-section">
            <h4><i data-lucide="folder"></i> Contains</h4>
            <div class="detail-list">
              ${data.contains.map(c => `
                <div class="detail-list-item">
                  <i data-lucide="check"></i>
                  <span>${c}</span>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      // Flow
      if (data.flow && data.flow.length > 0) {
        html += `
          <div class="detail-section">
            <h4><i data-lucide="activity"></i> How It Works</h4>
            <div class="flow-diagram">
              ${data.flow.map((f, i) => `
                <div class="flow-step">
                  <div class="flow-step-num">${i + 1}</div>
                  <div class="flow-step-content">
                    <div class="flow-step-title">${f.step}</div>
                    <div class="flow-step-desc">${f.desc}</div>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      // Children/Connections
      if (data.children && data.children.length > 0) {
        html += `
          <div class="detail-section">
            <h4><i data-lucide="git-branch"></i> Components (${data.children.length})</h4>
            <div class="connections-grid">
              ${data.children.map(c => `
                <div class="connection-item" onclick="navigateToNode('${c.name}')">
                  <div class="connection-dot" style="background: ${c.color}"></div>
                  <div class="connection-info">
                    <div class="connection-name">${c.name}</div>
                    <div class="connection-type">${(c.tech || []).slice(0, 2).join(', ')}</div>
                  </div>
                  <i data-lucide="chevron-right" class="connection-arrow" style="width: 14px; height: 14px;"></i>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      document.getElementById('detailContent').innerHTML = html;
      panel.classList.add('visible');
      lucide.createIcons();
    }

    function closeDetail() {
      document.getElementById('detailPanel').classList.remove('visible');
      g.selectAll('.tree-node').classed('selected', false);
      g.selectAll('.tree-link').classed('highlighted', false);
      // Don't remove satellites - they persist until toggled off
      selectedNode = null;
    }

    function navigateToNode(name) {
      // Find and select the node using the current rendered hierarchy
      if (!currentRoot) return;
      const target = currentRoot.descendants().find(d => d.data.name === name);
      if (target) {
        selectNode(target);
      }
    }

    // ============================================
    // CONTROLS
    // ============================================
    function setLayout(layout) {
      currentLayout = layout;
      document.querySelectorAll('.layout-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.layout === layout);
      });
      render();
      resetView();
    }

    function expandAll() {
      function expand(node) {
        if (node._children) {
          node.children = node._children;
          node._children = null;
        }
        if (node.children) node.children.forEach(expand);
      }
      expand(techTreeData);
      render();
    }

    function collapseAll() {
      function collapse(node) {
        if (node.children && node.children.length > 0) {
          node._children = node.children;
          node.children = null;
          node._children.forEach(collapse);
        }
      }
      if (techTreeData.children) {
        techTreeData.children.forEach(collapse);
      }
      render();
    }

    function toggleFlow() {
      showFlowAnimation = !showFlowAnimation;
      document.getElementById('flowToggleText').textContent = showFlowAnimation ? 'Hide Flow' : 'Show Flow';
      g.selectAll('.tree-link-animated').style('opacity', showFlowAnimation ? 1 : 0);
    }

    function resetView() {
      if (!currentRoot) return;

      const bounds = {
        minX: d3.min(currentRoot.descendants(), d => d.x) - nodeWidth,
        maxX: d3.max(currentRoot.descendants(), d => d.x) + nodeWidth,
        minY: d3.min(currentRoot.descendants(), d => d.y) - nodeHeight,
        maxY: d3.max(currentRoot.descendants(), d => d.y) + nodeHeight
      };

      const treeWidth = bounds.maxX - bounds.minX;
      const treeHeight = bounds.maxY - bounds.minY;
      const centerX = (bounds.minX + bounds.maxX) / 2;
      const centerY = (bounds.minY + bounds.maxY) / 2;

      // Calculate scale to fit the tree in view
      const scaleX = (width - 100) / treeWidth;
      const scaleY = (height - 100) / treeHeight;
      const scale = Math.min(scaleX, scaleY, 1); // Don't zoom in more than 100%

      svg.transition().duration(500).call(
        zoom.transform,
        d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(scale)
          .translate(-centerX, -centerY)
      );
    }

    // Sliders
    document.getElementById('nodeSizeSlider').addEventListener('input', function() {
      nodeScale = parseFloat(this.value);
      document.getElementById('nodeSizeValue').textContent = nodeScale.toFixed(1) + 'x';
      render();
    });

    document.getElementById('spacingSlider').addEventListener('input', function() {
      spacing = parseInt(this.value);
      document.getElementById('spacingValue').textContent = spacing;
      render();
    });

    // ============================================
    // MINIMAP
    // ============================================
    function updateMinimap() {
      const minimapSvg = d3.select('#minimapSvg');
      minimapSvg.selectAll('*').remove();

      // Use the already-rendered hierarchy (has x,y coordinates)
      if (!currentRoot) return;

      const bounds = {
        minX: d3.min(currentRoot.descendants(), d => d.x) - nodeWidth,
        maxX: d3.max(currentRoot.descendants(), d => d.x) + nodeWidth,
        minY: d3.min(currentRoot.descendants(), d => d.y) - nodeHeight,
        maxY: d3.max(currentRoot.descendants(), d => d.y) + nodeHeight
      };

      const mmWidth = 180;
      const mmHeight = 96;
      const scale = Math.min(mmWidth / (bounds.maxX - bounds.minX), mmHeight / (bounds.maxY - bounds.minY)) * 0.9;

      const mg = minimapSvg.append('g')
        .attr('transform', `translate(${mmWidth / 2}, ${mmHeight / 2}) scale(${scale}) translate(${-(bounds.minX + bounds.maxX) / 2}, ${-(bounds.minY + bounds.maxY) / 2})`);

      // Draw mini nodes
      currentRoot.descendants().forEach(d => {
        mg.append('rect')
          .attr('x', d.x - 10)
          .attr('y', d.y - 5)
          .attr('width', 20)
          .attr('height', 10)
          .attr('fill', d.data.color)
          .attr('rx', 2);
      });
    }

    // ============================================
    // KEYBOARD & EVENT LISTENERS
    // ============================================
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeDetail();
      if (e.key === '1') document.querySelector('[data-lens="tree"]').click();
      if (e.key.toLowerCase() === 'v') setLayout('vertical');
      if (e.key.toLowerCase() === 'h') setLayout('horizontal');
      if (e.key.toLowerCase() === 'r') setLayout('radial');
    });

    // Layout buttons
    document.querySelectorAll('.layout-btn').forEach(btn => {
      btn.addEventListener('click', () => setLayout(btn.dataset.layout));
    });

    // Lens tabs (placeholder - just tree view for now)
    document.querySelectorAll('.lens-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.lens-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        // For now, all show the tree view
      });
    });

    svg.on('click', closeDetail);

    // ============================================
    // INIT
    // ============================================
    lucide.createIcons();
    render();
    resetView();
  </script>
</body>
</html>
